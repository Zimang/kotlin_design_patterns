package top.zimang.structural_pat

import java.net.URL

/**
 * 类似于装饰者设计模式，代理设计模式可以增强对象的功能。
 * 然而，与始终遵循指令的装饰者不同，代理可能会选择不同的路径，在执行任务时表现出不同的行为。
 *
 * 在我们之前在第2章中讨论创建模式时，我们已经提到了昂贵对象的概念。这些对象可能依赖网络资源或需要大量时间来创建。
 * 想象一下我们有趣的猫咪应用的情景，我们在首页和移动应用中为用户提供每日幽默猫咪图片。
 * 用户在这些图片上互动时，会看到它们全屏显示。挑战在于从网络获取这些猫咪图片，这是一个资源密集型的过程，
 * 特别是当我们处理那些喜欢晚餐后甜点逃逸的猫咪图片时。
 *
 * 我们的目标很明确：我们希望仅在首次请求时检索全尺寸图片。
 *
 * 随后的请求应尽量避免网络获取，而是利用缓存内存中的结果。基本上，我们的目标是防止不必要的获取。
 *
 * 虽然最初加载图像是不可避免的，但我们的目标是为后续请求绕过冗余的网络往返。这就是代理设计模式的精髓。
 * 与每次都从网络获取的预期行为不同，我们采取了更从容的方式，提供我们已经准备好的缓存结果。
 *
 * 这个类比有点像进入一个价格实惠的小餐馆，点了一个汉堡，两分钟内就拿到了——尽管有点凉。
 * 为什么呢？因为别人不喜欢洋葱，之前退回厨房了。
 * 一个与我们概念相似的真实故事。
 */
fun main() {
    val cat = CatImage(
        "https://i.chzbgr.com/full/9026714368/hBB09ABBE/i-will-has-attention",
        "https://i.chzbgr.com/full/9026714368/hBB09ABBE/i-will-has-attention"
    )

    println(cat.image.size)
    println(cat.image.size)
}

/**
 * 现在，你可能会认为这涉及相当多的逻辑。然而，正如你可能从介绍装饰者设计模式中了解到的那样，
 * Kotlin擅长简化任务，最大程度地减少了需要大量样板代码来实现你的目标的需求。
 *
 * 之前，我们在不同的情境中见过 by 关键字的使用方式 - 即，当将接口的实现委托给另一个类时
 *  （正如本章节的装饰器部分所讨论的）。
 *
 *  你可能已经注意到，在这种情况下，我们使用 by 关键字来委托字段的初始化稍后进行。
 *
 *  我们使用了一个名为 lazy 的函数，它是 Kotlin 标准库中的一个委托函数之一。
 *  在第一次调用 image 属性时，它将执行我们的代码块并将结果保存到 image 属性中。
 *  随后对该属性的调用将简单地返回其值。
 *
 *  有时，代理设计模式被分为三个子模式：
 *
 *      1. 虚拟代理：延迟缓存结果
 *
 *      2. 远程代理：向远程资源发出调用
 *
 *      3. 保护或访问控制代理：拒绝未经授权的访问者。
 *
 *  您可以将我们的示例视为虚拟代理或虚拟和远程代理类型的组合。
 *
 *  # 代理与享元的不同
 *  | 对比点       | **Decorator**（装饰器）    | **Proxy**（代理）            |
 * | --------- | --------------------- | ------------------------ |
 * | 📌 目的     | 动态**增强功能**            | 控制**访问权限**或**延迟加载/远程调用** |
 * | 🧱 对象结构   | 包装真实对象，**扩展原有行为**     | 包装真实对象，**拦截并控制访问**       |
 * | 👀 客户端感知  | **不感知**装饰（与原对象接口一致）   | **不感知**代理（与原对象接口一致）      |
 * | 📦 是否改变行为 | ✅ 可添加/扩展新行为           | ⚠️ 通常不改变功能，只控制行为（如缓存）    |
 * | 🔧 使用场景   | 日志记录、权限扩展、视图增强等       | 权限校验、懒加载、远程代理、虚拟代理等      |
 * | 🔁 可堆叠性   | ✅ 支持多层装饰（可递归包装）       | ❌ 通常是单层代理                |
 * | 🏷 UML 结构 | 装饰器实现相同接口，**并持有组件引用** | 代理实现相同接口，**并持有被代理对象**    |
 *
 *     装饰器做“加法”，代理做“防火墙”
 *
 *     Decorator 是功能增强器
 *
 *     Proxy 是访问控制器
 */
data class CatImage(
    val thumbnailUrl: String,
    val url: String
) {
    /**
     * 1. 如果你觉得两个线程同时执行 lazy 代码块是可以接受的（也许这不会占用太多资源），你可以选择使用` lazy(LazyThreadSafetyMode.PUBLICATION)`。
     * 2. 对于性能至关重要的情况，且您完全确定两个线程永远不会同时执行相同的代码块，您可以使用`LazyThreadSafetyMode.NONE`，它不提供任何线程安全机制。代理和委托是解决许多复杂挑战的非常有效的方法。
     */
    val image: ByteArray by lazy {
        println("Fetching image, please wait")
        // Read image as bytes
        URL(url).readBytes()
    }
}