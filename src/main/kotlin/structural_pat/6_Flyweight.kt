package top.zimang.structural_pat
import java.io.File

/**
 * 轻量级是一个用来描述缺乏固有状态的对象的术语。术语“轻量级”暗示了它的轻量特性。
 *
 * 如果你一直在关注前面章节的内容，你可能已经在脑海中构想出应该是轻量级的某种对象：一个数据类。
 * 然而，数据类主要围绕着维护状态展开。
 *
 * 那么，我们能否在数据类概念和轻量级设计模式之间建立任何联系呢？
 *
 * 为了更深入地理解这个设计模式，让我们将时光倒流约二十年。
 * 1994年，当最初的《设计模式》一书出版时，一台标准个人电脑仅拥有4MB的RAM。
 * 在那个时代，由于存储容量有限，节约RAM是任何过程的首要目标。
 * 快进到今天，甚至一些智能手机现在拥有令人印象深刻的8GB RAM。
 * 在探索即将到来的章节中轻量级设计模式时，重要的是要记住这种演变。
 * 有了这种方法，让我们探讨优化资源利用的策略，这是一个持续且至关重要的考虑因素。
 *
 * 考虑这样一个情景：我们正在开发一款面向手机的2D平台游戏。
 * 玩家可以通过左右移动和跳跃来操控角色，可以使用方向键或游戏手柄。
 * 现在，有趣的地方来了：我们是一个小型独立团队。
 * 只有一个人负责所有事情——设计、管理、销售——而且我们还有两只猫和一只名叫迈克尔的金丝雀。
 *
 * 在我们的游戏中，我们只使用16种颜色，以保持简单和酷炫。
 * 主角是64像素高和64像素宽，这使得他在游戏世界中的大小很合适。
 * 在这个游戏中，主角面对的敌人大多是饥饿的坦桑尼亚蜗牛。这些蜗牛给游戏增添了一些趣味，使其更加刺激。
 *
 * # 享元注意
 * 确保我们提供的数据是不可变的至关重要。
 * 例如，在我们的单例中使用var而不是val可能会对我们的代码造成灾难性后果。
 * 对于可变数据结构也是同样的原则。我们不希望有人意外地移除、替换或抹去整个图像列表。
 * 当处理全局状态或包含可变状态的单例时，通常会遇到这些挑战。
 * 幸运的是，Kotlin简化了这些情况的管理。坚持使用val来处理您的外部状态，并选择一旦创建就无法修改的不可变数据结构。
 */
fun main() {
    // Flyweight allows us to create much more objects that otherwise possible
    val snails = List(10_000) {
        TansanianSnail()
    }
}

//由于这是一个2D游戏，每只蜗牛只能朝两个方向移动：左和右。
// 我们可以使用枚举类来表示这些方向：
enum class Direction {
    LEFT,
    RIGHT
}

class TansanianSnail {
    val directionFacing = Direction.LEFT

    // This is the Flyweight we're using
    val sprites = SnailSprites.sprites

    /**
     * 根据方向，我们可以获取当前的精灵，显示蜗牛面朝的方向，并用此来绘制它
     * 当任何敌人移动时，它们基本上只是向左或向右滑动。
     * 我们希望的是为每个方向上的蜗牛移动制作多个动画精灵。
     */
    fun getCurrentSprite(): File {
        return when (directionFacing) {
            Direction.LEFT -> sprites[0]
            Direction.RIGHT -> sprites[1]
        }
    }

    // More information about the state of a snail comes here

    // This may include its health, for example
}

/**
 * 在这部分，我们首先通过使用一个称为“块”函数的特殊函数来列出八项。
 * 这样，我们可以创建一个集合，同时为每个元素的创建添加复杂规则。
 * 而很酷的是，这个集合是不可变的。对于列表中的每个元素，我们会决定使用哪张图片：
 *
 *  1. 第一和第二位置是用于角色静止时，面向左和右的图片。
 *
 *  2. 第三到第五位置是用于角色向左移动时的图片。
 *
 *  3. 第六到第八位置是用于角色向右移动时的图片。
 *
 *  现在，让我们谈谈数字。每只蜗牛有一张64像素乘64像素的图片。
 *  如果图片中的每种颜色就像是一小块数据，那么每张图片大约需要1字节的空间。
 *  因此，一张图片需要4 KB的内存。对于每只蜗牛的八张图片，我们需要32 KB的内存。
 *  这意味着我们可以在1 MB的内存中容纳大约32只蜗牛。
 *
 *  但是，我们有很大的计划 - 我们想在屏幕上放很多这些快速而危险的蜗牛，甚至在老手机上也能运行。
 *  因此，很明显我们需要找到一个更聪明的方法来实现这一目标。
 *
 *  我们正在处理的问题是我们的蜗牛有点胖，实际上相当沉重。
 *  我们的目标是让它们瘦下来一点。目前，每只蜗牛身上携带着大约八张图像，都打包在它蜗牛般的身体内。
 *  有趣的是，这些图像对于每只蜗牛来说都是相同的。
 *
 *  这让我们思考：如果我们能够将这些图像集合存储在一个共享对象中（比如一个单例），
 *      或者创建一个方法来生成它们（一个工厂方法），那么对于每只蜗牛，
 *      我们只需引用这些共享图像，而不是重复它们。
 *
 *  通过采用这种方法，我们的getCurrentSprite函数可以保持不变，内存使用量将保持在256 KB，无论我们创建多少只蜗牛。
 *  我们可以轻松生成无数只蜗牛，而不会对程序的内存使用造成任何显著影响。
 *  这个概念与享元设计模式完美契合。
 *
 *  这里的核心概念是通过让大量对象（在我们的场景中是图像文件）在资源消耗较少的对象（在我们的场景中是蜗牛）
 *  之间共享来控制数量。这个巧妙的策略确保资源的高效利用，并使我们能够管理大量对象而不会过载内存。
 */
object SnailSprites {
    val sprites = List(8) { i ->
        java.io.File(
            when (i) {
                0 -> "snail-left.jpg"
                1 -> "snail-right.jpg"
                in 2..4 -> "snail-move-left-${i - 1}.jpg"
                else -> "snail-move-right${(4 - i)}.jpg"
            }
        )
    }
}