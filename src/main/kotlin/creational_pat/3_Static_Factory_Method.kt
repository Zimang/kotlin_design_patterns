package top.zimang.creational_pat


/**
 * 有一个名字类似的设计模式，经常与工厂方法模式混淆，被称为静态工厂方法设计模式。
 * 这个模式在《设计模式》一书中有描述，实现略有不同。
 * 它通过Joshua Bloch的《Effective Java》一书而广受欢迎。
 * 为了更好地理解，让我们从Java标准库中的一些示例，特别是valueOf()方法中探索一下。
 * Java标准库提供了两种方法来从字符串构造一个Long对象（64位整数）：
 *      Long l1 = new Long("1"); // Using constructor
 *      Long l2 = Long.valueOf("1"); // Using static factory method
 * 好处
 * • 明确命名：它允许更具描述性地命名对象构造函数，特别是在一个类有多个构造函数时。这提高了代码的可读性，使每个构造函数的目的更加清晰。
 * • 异常处理：虽然构造函数通常不应该抛出异常，但静态工厂方法可以，从而实现更明确和灵活的错误处理。这承认了对象实例化确实可能失败。
 * • 对象创建的灵活性：静态工厂方法可以为对象创建提供不同的策略。例如，它们可以为具有复杂或缓慢构建过程的对象提供优化或缓存机制。
 *
 * 对于3 静态工厂方法设计模式可以集成缓存功能。
 *          比如，在Java中的Long.valueOf()方法，并不总是创建一个新实例。
 *          相反，它会检查缓存以查看该值是否之前已被解析过。
 *          如果是，它会返回一个缓存的实例，减少垃圾回收并通过重用实例来提高性能。
 *       此外，当调用构造函数时总是创建一个特定类的实例，而静态工厂方法可以生成该类本身或其子类的实例。
 *          这种灵活性允许根据条件或配置进行动态对象创建。
 *
 * 在某些情况下，我们可能希望限制对象的实例化只能通过静态工厂方法来进行。为了实现这一点，我们可以将类的默认构造函数声明为私有
 * class Server private constructor(port: Long) {...}
 */

class Server private constructor(port: Long) {

    init {
        println("Server started on port $port")
    }

    companion object {
        /**
         * 伴生对象可以有一个名称 - 例如，伴生对象，但这只是为了清楚地说明对象的目标是什么。
         *
         * 伴生对象拥有自己的方法，这种构造的好处类似于Java中的静态方法。
         * 当你在伴生对象上调用方法时，它会在首次访问包含类时延迟实例化对象。这样可以实现按需初始化和高效资源利用。
         *
         * 一个类只能有一个伴生对象。
         */
        fun withPort(port: Long): Server {
            return Server(port)
        }
    }
}


fun main() {
    Server.withPort(8080)
}

